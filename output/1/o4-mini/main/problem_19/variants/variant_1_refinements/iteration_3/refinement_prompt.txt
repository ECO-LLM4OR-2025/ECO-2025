You are an expert operations research analyst. Based on the detailed diagnostic evaluation below, please generate an improved Gurobi solution for this optimization problem.

    ## Problem Description:
    A furniture store can choose to order chairs from three different manufacturers: A, B, and C. The cost of ordering each chair from manufacturer A is $50, from manufacturer B is $45, and from manufacturer C is $40. The store needs to minimize the total cost of the order.

Additionally, each order from manufacturer A will include 15 chairs, while each order from manufacturers B and C will include 10 chairs. The number of orders must be an integer. The store needs to order at least 100 chairs.

Each order from manufacturer A will include 15 chairs, while each order from manufacturers B and C will include 10 chairs. The store needs to order at most 500 chairs.

If the store decides to order chairs from manufacturer A, it must also order at least 10 chairs from manufacturer B.

Furthermore, if the store decides to order chairs from manufacturer B, it must also order chairs from manufacturer C.

    ## Current Iteration: 3

    ## Diagnostic Evaluation Results:
    **DIMENSION 1 - Definition Consistency:**  
Diagnosis:  
All entities and parameters in the code match the verbal problem statement.  The variables x[A], x[B], x[C] represent integer numbers of orders from each manufacturer, and y[A], y[B], y[C] correctly indicate whether we use each supplier.  Chairs-per-order and cost-per-order values exactly reflect 15 chairs at \$50 for A, 10 chairs at \$45 for B, and 10 chairs at \$40 for C.  The total-chairs bounds (100 ≤ chairs ≤ 500) are represented correctly.  
Issues Found: None  
Confidence: High  

**DIMENSION 2 - Structural Soundness:**  
Diagnosis:  
The model is a Mixed-Integer Linear Program with a minimization objective, as required.  The objective sums cost_per_order[m]·x[m], which correctly minimizes total cost.  Constraints include (1) total chairs between 100 and 500, (2) linking x[m] and y[m] via big-M and x[m] ≥ y[m], and (3) the logical implications y[A] ≤ y[B] and y[B] ≤ y[C].  No required constraints are missing, and there are no redundancies that affect feasibility or optimality.  Variable types (integer for x, binary for y) are correctly specified.  
Issues Found: None  
Confidence: High  

**DIMENSION 3 - Numerical Validity:**  
Diagnosis:  
The solver returns an optimal objective value of 4000, which corresponds to ordering 10 batches from manufacturer C only (10 × 10 chairs = 100 chairs at \$400 each = \$4,000).  This is exactly the cheapest feasible plan and respects all logical implications (since A and B are unused, B⇒C and A⇒B still hold).  There is no indication of infeasibility or unboundedness, and all coefficients and right-hand sides are in the correct numerical ranges.  
Issues Found: None  
Confidence: High  

OVERALL ASSESSMENT:  
Primary Issues: None identified—model fully aligns with the problem.  
Recommended Actions:  
• No corrections needed; the formulation is sound.  
• Optionally, you can remove unused variables or tighten big-M values for efficiency, but these are purely implementation refinements rather than fixes.

    ## Current 5element to Improve:
    No 5element_description

    ## Current Solution to Improve:
    ```python
    import gurobipy as gp
from gurobipy import GRB

def main():
    try:
        # Create a new model
        model = gp.Model("FurnitureOrder")
        
        # Suppress solver output for cleaner logs
        model.Params.OutputFlag = 0
        # Fix random seed for reproducibility
        model.Params.Seed = 1

        # Data
        manufacturers = ['A', 'B', 'C']
        chairs_per_order = {'A':15, 'B':10, 'C':10}
        cost_per_order   = {'A':15*50, 'B':10*45, 'C':10*40}
        min_chairs = 100
        max_chairs = 500

        # Big-M for each manufacturer (max possible orders)
        max_orders = {m: max_chairs // chairs_per_order[m] for m in manufacturers}

        # Decision variables
        # x[m]: integer number of orders from m, 0 <= x[m] <= max_orders[m]
        # y[m]: binary indicator whether we order at least once from m
        x = model.addVars(
            manufacturers,
            vtype=GRB.INTEGER,
            lb=0,
            ub=max_orders,
            name="x"
        )
        y = model.addVars(
            manufacturers,
            vtype=GRB.BINARY,
            name="y"
        )

        # Objective: minimize total ordering cost
        model.setObjective(
            gp.quicksum(cost_per_order[m] * x[m] for m in manufacturers),
            GRB.MINIMIZE
        )

        # 1) Total chairs constraints: between min_chairs and max_chairs
        model.addConstr(
            gp.quicksum(chairs_per_order[m] * x[m] for m in manufacturers) 
            >= min_chairs,
            name="MinTotalChairs"
        )
        model.addConstr(
            gp.quicksum(chairs_per_order[m] * x[m] for m in manufacturers) 
            <= max_chairs,
            name="MaxTotalChairs"
        )

        # 2) Linking x and y: if y[m]=0 => x[m]=0; if y[m]=1 => x[m]>=1
        model.addConstrs(
            (x[m] <= max_orders[m] * y[m] for m in manufacturers),
            name="Link_x_le_My"
        )
        model.addConstrs(
            (x[m] >= y[m] for m in manufacturers),
            name="Link_x_ge_y"
        )

        # 3) Logical implications:
        #    If orders from A => must order from B; A ⇒ B: y[A] <= y[B]
        #    If orders from B => must order from C; B ⇒ C: y[B] <= y[C]
        model.addConstr(y['A'] <= y['B'], name="IfAthenB")
        model.addConstr(y['B'] <= y['C'], name="IfBthenC")

        # Optimize the model
        model.optimize()

        # After optimization, write only the optimal value to file
        if model.Status == GRB.OPTIMAL:
            opt_val = model.ObjVal
            try:
                with open('ref_optimal_value.txt', 'w') as f:
                    f.write(f"{int(opt_val)}")
            except IOError as ioe:
                print(f"File write error: {ioe}")
        else:
            print(f"Solver ended with status {model.Status}")

    except gp.GurobiError as ge:
        print(f"Gurobi error: {ge.errno} - {ge}")
    except Exception as e:
        print(f"Unexpected error: {e}")

if __name__ == "__main__":
    main()
    ```

    ## Instructions for Improvement:

    Based on the diagnostic evaluation above, please generate a completely new and improved Gurobi code that addresses ALL identified issues. 

    **Requirements:**
    1. Address each issue identified in the diagnostic evaluation
    2. Ensure the code can run successfully without errors
    3. Save the final optimal value to 'ref_optimal_value.txt' (value only, no extra text)
    4. Use proper Gurobi syntax and best practices
    5. Include appropriate error handling
    6. Add clear comments explaining key modeling decisions

    **Code Generation Format:**
    First, provide a brief explanation of the key improvements you're making, then provide the complete code between ===== markers:

    Key Improvements:
    [Explain the main changes you're making to address the identified issues]

    =====
    import gurobipy as gp
    from gurobipy import GRB

    # Your improved code here
    # Make sure to save only the optimal value to 'ref_optimal_value.txt'
    =====

    Please ensure the generated code is complete, executable, and addresses all the issues identified in the diagnostic evaluation.
    