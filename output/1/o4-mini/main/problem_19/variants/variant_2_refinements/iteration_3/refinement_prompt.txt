You are an expert operations research analyst. Based on the detailed diagnostic evaluation below, please generate an improved Gurobi solution for this optimization problem.

    ## Problem Description:
    A furniture store can choose to order chairs from three different manufacturers: A, B, and C. The cost of ordering each chair from manufacturer A is $50, from manufacturer B is $45, and from manufacturer C is $40. The store needs to minimize the total cost of the order.

Additionally, each order from manufacturer A will include 15 chairs, while each order from manufacturers B and C will include 10 chairs. The number of orders must be an integer. The store needs to order at least 100 chairs.

Each order from manufacturer A will include 15 chairs, while each order from manufacturers B and C will include 10 chairs. The store needs to order at most 500 chairs.

If the store decides to order chairs from manufacturer A, it must also order at least 10 chairs from manufacturer B.

Furthermore, if the store decides to order chairs from manufacturer B, it must also order chairs from manufacturer C.

    ## Current Iteration: 3

    ## Diagnostic Evaluation Results:
    **DIMENSION 1 - Definition Consistency:**  
Diagnosis:  
All decision variables (x[i] = number of orders, y[i] = binary “use” flag) are named clearly and map directly to the ordering problem as stated. Parameters for chairs per order and cost per chair match exactly the problem description (A: 15 chairs @ \$50, B: 10 chairs @ \$45, C: 10 chairs @ \$40) and the min/max chair requirements (100 ≤ total ≤ 500) are correctly encoded. The manufacturer “entities” and their logical relationships (A⇒B, B⇒C) are all represented.  
Issues Found:  
None  
Confidence: High  

**DIMENSION 2 - Structural Soundness:**  
Diagnosis:  
The model is a mixed‐integer linear program with the correct minimization objective (total cost) and properly specified integer and binary variables. All stated logical implications and quantity bounds are included. The big‐M linking constraints correctly force x[i]=0 when y[i]=0 and x[i]≥1 when y[i]=1.  
Issues Found:  
• There is one redundant constraint:  
 – “min_B_chairs_if_A” (10·x[B] ≥ 10·y[A]) is already implied by y[A] ≤ y[B] plus x[B] ≥ y[B].  
No missing constraints or formulation errors were detected.  
Confidence: High  

**DIMENSION 3 - Numerical Validity:**  
Diagnosis:  
The solver reports an optimal cost of \$4,000, achieved by placing 10 orders with manufacturer C (10×10 chairs = 100 chairs), which is both feasible (meets all quantity and logical‐implication constraints) and intuitively minimal since C is cheapest per chair. There are no numerical issues (infeasibility or unboundedness), and big‐M values are tight.  
Issues Found:  
None  
Confidence: High  

**OVERALL ASSESSMENT:**  
Primary Issues:  
1. Redundant “min_B_chairs_if_A” constraint (logic already enforced by y[A]≤y[B] and x[B]≥y[B]).  

Recommended Actions:  
– Remove the redundant B‐chairs‐if‐A constraint to simplify the model.  
– As a best practice, retain the tightened M values and linking constraints, since they are correctly computed and help solver performance.  
– (Optional) Add comments in the code explaining each logical implication to aid future maintenance.

    ## Current 5element to Improve:
    No 5element_description

    ## Current Solution to Improve:
    ```python
    import gurobipy as gp
from gurobipy import GRB, GurobiError
import math

# Data
manufacturers    = ['A', 'B', 'C']
chairs_per_order = {'A': 15, 'B': 10, 'C': 10}
cost_per_chair   = {'A': 50, 'B': 45, 'C': 40}
min_chairs       = 100
max_chairs       = 500

# Compute a tighter big-M for each manufacturer
M = {i: math.ceil(max_chairs / chairs_per_order[i]) for i in manufacturers}

# Precompute cost per order = cost per chair × chairs per order
cost_per_order = {i: cost_per_chair[i] * chairs_per_order[i] for i in manufacturers}

try:
    # Initialize model
    model = gp.Model("chair_ordering")
    # (Optional) suppress detailed Gurobi output
    model.setParam('OutputFlag', 0)

    # Decision variables
    # x[i] = # of orders (integer)
    x = model.addVars(manufacturers, vtype=GRB.INTEGER, lb=0, name="x")
    # y[i] = 1 if we place at least one order from i, else 0
    y = model.addVars(manufacturers, vtype=GRB.BINARY, name="y")

    # Link x and y:
    #   if y[i] = 0 then x[i] = 0
    #   if y[i] = 1 then 1 ≤ x[i] ≤ M[i]
    for i in manufacturers:
        model.addConstr(x[i] >= y[i], name=f"link_min_{i}")
        model.addConstr(x[i] <= M[i] * y[i], name=f"link_max_{i}")

    # Logical implications
    # If we use A, we must use B
    model.addConstr(y['A'] <= y['B'], name="A_implies_B")
    # If we use B, we must use C
    model.addConstr(y['B'] <= y['C'], name="B_implies_C")

    # If we use A, we must order at least 10 chairs from B
    model.addConstr(
        chairs_per_order['B'] * x['B'] >= 10 * y['A'],
        name="min_B_chairs_if_A"
    )

    # Total chairs constraints
    total_chairs = gp.quicksum(chairs_per_order[i] * x[i] for i in manufacturers)
    model.addConstr(total_chairs >= min_chairs, name="min_chairs")
    model.addConstr(total_chairs <= max_chairs, name="max_chairs")

    # Objective: minimize total cost = sum(cost_per_order[i] * x[i])
    model.setObjective(
        gp.quicksum(cost_per_order[i] * x[i] for i in manufacturers),
        GRB.MINIMIZE
    )

    # Optimize
    model.optimize()

    # Extract optimal value if available
    optimal_value = None
    if model.status == GRB.OPTIMAL:
        optimal_value = model.objVal

except GurobiError:
    optimal_value = None

# Write only the numeric optimal value to file
try:
    with open('ref_optimal_value.txt', 'w') as f:
        if optimal_value is not None:
            f.write(str(optimal_value))
except IOError:
    # Silently ignore file I/O errors
    pass
    ```

    ## Instructions for Improvement:

    Based on the diagnostic evaluation above, please generate a completely new and improved Gurobi code that addresses ALL identified issues. 

    **Requirements:**
    1. Address each issue identified in the diagnostic evaluation
    2. Ensure the code can run successfully without errors
    3. Save the final optimal value to 'ref_optimal_value.txt' (value only, no extra text)
    4. Use proper Gurobi syntax and best practices
    5. Include appropriate error handling
    6. Add clear comments explaining key modeling decisions

    **Code Generation Format:**
    First, provide a brief explanation of the key improvements you're making, then provide the complete code between ===== markers:

    Key Improvements:
    [Explain the main changes you're making to address the identified issues]

    =====
    import gurobipy as gp
    from gurobipy import GRB

    # Your improved code here
    # Make sure to save only the optimal value to 'ref_optimal_value.txt'
    =====

    Please ensure the generated code is complete, executable, and addresses all the issues identified in the diagnostic evaluation.
    