You are an expert operations research analyst. Based on the detailed diagnostic evaluation below, please generate an improved Gurobi solution for this optimization problem.

    ## Problem Description:
    A furniture store can choose to order chairs from three different manufacturers: A, B, and C. The cost of ordering each chair from manufacturer A is $50, from manufacturer B is $45, and from manufacturer C is $40. The store needs to minimize the total cost of the order.

Additionally, each order from manufacturer A will include 15 chairs, while each order from manufacturers B and C will include 10 chairs. The number of orders must be an integer. The store needs to order at least 100 chairs.

Each order from manufacturer A will include 15 chairs, while each order from manufacturers B and C will include 10 chairs. The store needs to order at most 500 chairs.

If the store decides to order chairs from manufacturer A, it must also order at least 10 chairs from manufacturer B.

Furthermore, if the store decides to order chairs from manufacturer B, it must also order chairs from manufacturer C.

    ## Current Iteration: 2

    ## Diagnostic Evaluation Results:
    **DIMENSION 1 - Definition Consistency:**  
Diagnosis:  
- All decision variables and parameters map directly to the textual description.  
- x[i] counts integer orders, y[i] flags whether we order at least one lot.  
- chairs_per_order and cost_per_chair are set correctly to 15/10/10 and \$50/\$45/\$40.  
- The at-least-100 and at-most-500 chair requirements are represented.  
- Logical “if A then ≥10 chairs from B” and “if B then C” are captured via y-linking.  
Issues Found: None  
Confidence: High  

**DIMENSION 2 - Structural Soundness:**  
Diagnosis:  
- The objective minimizes total cost = (cost_per_chair × chairs_per_order × x).  
- All linkage constraints x ≥ y and x ≤ Mᵢ·y ensure y correctly indicates usage.  
- Logical implications y[A] ≤ y[B] and y[B] ≤ y[C] match “A⇒B” and “B⇒C.”  
- Chair-count constraints enforce the global min/max.  
- The model is a MILP (integer x, binary y) which is appropriate.  
- No redundant or missing constraints; the big-M values are valid upper bounds.  
Issues Found: None  
Confidence: High  

**DIMENSION 3 - Numerical Validity:**  
Diagnosis:  
- The solver converged to \$4 000, which corresponds to ordering 10 batches from C (10×10 chairs at \$40 each = 100 chairs, \$4 000).  
- This is the cheapest per-chair source and satisfies all min/max and logical rules, so the result is sensible.  
- No infeasibility or unboundedness occurred; all coefficients and RHS values are within expected ranges.  
Issues Found: None  
Confidence: High  

**OVERALL ASSESSMENT:**  
Primary Issues: None – the formulation fully and correctly represents the stated problem.  
Recommended Actions:  
- No changes required for correctness.  
- (Optional) For marginal performance gain, one could tighten big-M by using `ceil(max_chairs/chairs_per_order[i])` instead of floor, but the current M values are already valid.

    ## Current 5element to Improve:
    No 5element_description

    ## Current Solution to Improve:
    ```python
    import gurobipy as gp
from gurobipy import GRB, GurobiError

# Data
manufacturers   = ['A', 'B', 'C']
chairs_per_order = {'A': 15, 'B': 10, 'C': 10}
cost_per_chair   = {'A': 50, 'B': 45, 'C': 40}
min_chairs       = 100
max_chairs       = 500

# Dynamically compute big-M: maximum possible orders for each manufacturer
M = {i: max_chairs // chairs_per_order[i] for i in manufacturers}

try:
    # Initialize model
    model = gp.Model("chair_ordering")

    # Decision variables
    # x[i]: integer # of orders from manufacturer i
    x = model.addVars(manufacturers, vtype=GRB.INTEGER, lb=0, name="orders")
    # y[i]: binary flag, 1 if we place ≥1 order from i
    y = model.addVars(manufacturers, vtype=GRB.BINARY, name="used")

    # Link x and y: if y[i]=0 then x[i]=0; if y[i]=1 then x[i]≥1 and ≤M[i]
    for i in manufacturers:
        model.addConstr(x[i] >= y[i],             name=f"min_order_{i}")
        model.addConstr(x[i] <= M[i] * y[i],       name=f"max_order_{i}")

    # Logical implications
    # If A is used then B must be used
    model.addConstr(y['A'] <= y['B'], name="A_implies_B")
    # If B is used then C must be used
    model.addConstr(y['B'] <= y['C'], name="B_implies_C")

    # Total chairs constraints
    model.addConstr(
        gp.quicksum(chairs_per_order[i] * x[i] for i in manufacturers) >= min_chairs,
        name="min_chairs"
    )
    model.addConstr(
        gp.quicksum(chairs_per_order[i] * x[i] for i in manufacturers) <= max_chairs,
        name="max_chairs"
    )

    # Objective: minimize total cost
    #   cost_per_chair × chairs_per_order × #orders
    model.setObjective(
        gp.quicksum(cost_per_chair[i] * chairs_per_order[i] * x[i]
                    for i in manufacturers),
        GRB.MINIMIZE
    )

    # Solve
    model.optimize()

    # Extract optimal cost if found
    if model.status == GRB.OPTIMAL:
        optimal_value = model.objVal
    else:
        optimal_value = None

except GurobiError:
    optimal_value = None

# Write only the numeric optimal value (no extra text) to file
try:
    with open('ref_optimal_value.txt', 'w') as f:
        if optimal_value is not None:
            f.write(str(optimal_value))
        else:
            # leave file blank if no optimal solution
            pass
except IOError:
    # silently ignore file I/O errors
    pass
    ```

    ## Instructions for Improvement:

    Based on the diagnostic evaluation above, please generate a completely new and improved Gurobi code that addresses ALL identified issues. 

    **Requirements:**
    1. Address each issue identified in the diagnostic evaluation
    2. Ensure the code can run successfully without errors
    3. Save the final optimal value to 'ref_optimal_value.txt' (value only, no extra text)
    4. Use proper Gurobi syntax and best practices
    5. Include appropriate error handling
    6. Add clear comments explaining key modeling decisions

    **Code Generation Format:**
    First, provide a brief explanation of the key improvements you're making, then provide the complete code between ===== markers:

    Key Improvements:
    [Explain the main changes you're making to address the identified issues]

    =====
    import gurobipy as gp
    from gurobipy import GRB

    # Your improved code here
    # Make sure to save only the optimal value to 'ref_optimal_value.txt'
    =====

    Please ensure the generated code is complete, executable, and addresses all the issues identified in the diagnostic evaluation.
    