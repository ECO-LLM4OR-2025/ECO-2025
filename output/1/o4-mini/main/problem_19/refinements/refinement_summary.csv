status,iterations,optimal_value,path,convergence_reason,consecutive_same_count,5element_description,code,evaluation_result,problem_id,variant
Converged,3,4000,/root/eco/ECO-2025-v3-wjx/output/1/o4-mini/main/problem_19/variants/variant_0_refinements/iteration_3,no_change_for_3_iterations,3,,"import gurobipy as gp
from gurobipy import GRB

def main():
    try:
        # -------------------------
        # Problem Data
        # -------------------------
        manufacturers    = [""A"", ""B"", ""C""]
        chairs_per_order = {""A"": 15, ""B"": 10, ""C"": 10}
        cost_per_chair   = {""A"": 50, ""B"": 45, ""C"": 40}
        min_chairs       = 100
        max_chairs       = 500

        # Compute derived parameters
        cost_per_order = {m: chairs_per_order[m] * cost_per_chair[m]
                          for m in manufacturers}
        # Big-M on orders (max possible orders per manufacturer)
        max_orders = {m: max_chairs // chairs_per_order[m]
                      for m in manufacturers}

        # -------------------------
        # Model Initialization
        # -------------------------
        model = gp.Model(""furniture_ordering"")
        model.Params.OutputFlag = 0  # Silent mode

        # Decision Variables
        x = model.addVars(manufacturers,
                          vtype=GRB.INTEGER, lb=0,
                          name=""num_orders"")
        y = model.addVars(manufacturers,
                          vtype=GRB.BINARY,
                          name=""use_flag"")

        # -------------------------
        # Constraints
        # -------------------------
        # 1) Total chairs between min and max
        total_chairs = gp.quicksum(chairs_per_order[m] * x[m]
                                   for m in manufacturers)
        model.addConstr(total_chairs >= min_chairs, name=""min_total_chairs"")
        model.addConstr(total_chairs <= max_chairs, name=""max_total_chairs"")

        # 2) Link x and y: if y[m]=0 → x[m]=0; if y[m]=1 → x[m] ≥ 1
        for m in manufacturers:
            model.addConstr(x[m] <= max_orders[m] * y[m],
                            name=f""link_up_{m}"")
            model.addConstr(x[m] >= y[m],
                            name=f""link_low_{m}"")

        # 3) Logical implications with explicit chair counts
        #    If A is used then at least 10 chairs from B
        model.addConstr(chairs_per_order[""B""] * x[""B""]
                        >= 10 * y[""A""],
                        name=""A_implies_10chairs_from_B"")
        #    If B is used then at least 10 chairs from C
        model.addConstr(chairs_per_order[""C""] * x[""C""]
                        >= 10 * y[""B""],
                        name=""B_implies_10chairs_from_C"")

        # 4) Standard logical chain (ensures ordering flags align)
        model.addConstr(y[""A""] <= y[""B""], name=""A_implies_B_flag"")
        model.addConstr(y[""B""] <= y[""C""], name=""B_implies_C_flag"")

        # -------------------------
        # Objective: Minimize total cost
        # -------------------------
        total_cost = gp.quicksum(cost_per_order[m] * x[m]
                                 for m in manufacturers)
        model.setObjective(total_cost, GRB.MINIMIZE)

        # -------------------------
        # Solve
        # -------------------------
        model.optimize()

        # -------------------------
        # Retrieve and save optimal value
        # -------------------------
        if model.Status == GRB.OPTIMAL:
            opt_val = int(model.ObjVal)
            try:
                with open(""ref_optimal_value.txt"", ""w"") as f:
                    f.write(str(opt_val))
            except IOError as io_err:
                print(f""Error writing output file: {io_err}"")
        else:
            print(f""Optimization ended with status {model.Status}"")

    except gp.GurobiError as ge:
        print(f""Gurobi error: {ge}"")
    except Exception as ex:
        print(f""Unexpected error: {ex}"")

if __name__ == ""__main__"":
    main()",,19,variant_0
Converged,3,4000,/root/eco/ECO-2025-v3-wjx/output/1/o4-mini/main/problem_19/variants/variant_1_refinements/iteration_3,no_change_for_3_iterations,3,,"import gurobipy as gp
from gurobipy import GRB

def main():
    try:
        # Create the model
        model = gp.Model(""FurnitureOrdering"")
        # Silence solver output for clean logs
        model.Params.OutputFlag = 0
        # Fix random seed for reproducibility
        model.Params.Seed = 42

        # --- Data Definitions ---
        manufacturers    = ['A', 'B', 'C']
        chairs_per_order = {'A': 15, 'B': 10, 'C': 10}
        cost_per_order   = {'A': 15*50, 'B': 10*45, 'C': 10*40}
        min_chairs       = 100
        max_chairs       = 500
        # Compute the maximum number of orders possible per manufacturer
        max_orders = {m: max_chairs // chairs_per_order[m] for m in manufacturers}

        # --- Decision Variables ---
        # x[m]: integer number of orders from manufacturer m
        x = model.addVars(manufacturers,
                          vtype=GRB.INTEGER,
                          lb=0,
                          ub=max_orders,
                          name=""x"")
        # y[m]: binary flag, 1 if we order at least one batch from m
        y = model.addVars(manufacturers,
                          vtype=GRB.BINARY,
                          name=""y"")

        # --- Objective: Minimize total cost ---
        model.setObjective(
            gp.quicksum(cost_per_order[m] * x[m] for m in manufacturers),
            GRB.MINIMIZE
        )

        # --- Constraints ---

        # 1) Total chairs ordered between 100 and 500
        total_chairs = gp.quicksum(chairs_per_order[m] * x[m] for m in manufacturers)
        model.addConstr(total_chairs >= min_chairs, name=""MinChairs"")
        model.addConstr(total_chairs <= max_chairs, name=""MaxChairs"")

        # 2) Link x and y with indicator constraints:
        #    If y[m] = 1 ⇒ x[m] ≥ 1
        #    If y[m] = 0 ⇒ x[m] = 0
        for m in manufacturers:
            model.addGenConstrIndicator(y[m], 1, x[m] >= 1,
                                        name=f""Ind_x_ge1_if_y_{m}"")
            model.addGenConstrIndicator(y[m], 0, x[m] == 0,
                                        name=f""Ind_x_eq0_if_not_y_{m}"")

        # 3) Logical supplier implications:
        #    A ⇒ B  (y[A] ≤ y[B]),  B ⇒ C  (y[B] ≤ y[C])
        model.addConstr(y['A'] <= y['B'], name=""IfAthenB"")
        model.addConstr(y['B'] <= y['C'], name=""IfBthenC"")

        # --- Optimize ---
        model.optimize()

        # --- Output ---
        if model.Status == GRB.OPTIMAL:
            optimal_value = int(model.ObjVal)
            try:
                with open('ref_optimal_value.txt', 'w') as fout:
                    fout.write(f""{optimal_value}"")
            except IOError as io_err:
                print(f""Error writing output file: {io_err}"")
        else:
            print(f""Model did not solve to optimality. Status code: {model.Status}"")

    except gp.GurobiError as grb_err:
        print(f""Gurobi Error {grb_err.errno}: {grb_err}"")
    except Exception as ex:
        print(f""Unexpected error: {ex}"")

if __name__ == ""__main__"":
    main()",,19,variant_1
Converged,3,4000.0,/root/eco/ECO-2025-v3-wjx/output/1/o4-mini/main/problem_19/variants/variant_2_refinements/iteration_3,no_change_for_3_iterations,3,,"import gurobipy as gp
from gurobipy import GRB, GurobiError
import math

# Data definition
manufacturers    = ['A', 'B', 'C']
chairs_per_order = {'A': 15, 'B': 10, 'C': 10}
cost_per_chair   = {'A': 50, 'B': 45, 'C': 40}
min_chairs       = 100
max_chairs       = 500

# Precompute big-M per manufacturer (max possible orders)
M = {m: math.ceil(max_chairs / chairs_per_order[m]) for m in manufacturers}

# Precompute cost per order
cost_per_order = {m: cost_per_chair[m] * chairs_per_order[m] for m in manufacturers}

optimal_value = None

try:
    # Initialize Gurobi model
    model = gp.Model(""chair_ordering"")
    # Suppress solver output for clarity
    model.setParam('OutputFlag', 0)

    # Decision variables:
    # x[m] = integer number of orders from manufacturer m
    # y[m] = binary flag, 1 if any order is placed from m, 0 otherwise
    x = model.addVars(manufacturers, vtype=GRB.INTEGER, lb=0, name=""x"")
    y = model.addVars(manufacturers, vtype=GRB.BINARY, name=""y"")

    # Link x and y with tight big-M:
    #   y[m] = 0 ⇒ x[m] = 0
    #   y[m] = 1 ⇒ 1 ≤ x[m] ≤ M[m]
    for m in manufacturers:
        model.addConstr(x[m] >= y[m],           name=f""link_min_{m}"")
        model.addConstr(x[m] <= M[m] * y[m],    name=f""link_max_{m}"")

    # Logical implications between manufacturers:
    # If we order from A, we must order from B; if from B, must order from C
    model.addConstr(y['A'] <= y['B'], name=""A_implies_B"")
    model.addConstr(y['B'] <= y['C'], name=""B_implies_C"")

    # Total chairs constraints
    total_chairs = gp.quicksum(chairs_per_order[m] * x[m] for m in manufacturers)
    model.addConstr(total_chairs >= min_chairs, name=""min_chairs"")
    model.addConstr(total_chairs <= max_chairs, name=""max_chairs"")

    # Objective: minimize total cost
    model.setObjective(
        gp.quicksum(cost_per_order[m] * x[m] for m in manufacturers),
        GRB.MINIMIZE
    )

    # Optimize the model
    model.optimize()

    if model.status == GRB.OPTIMAL:
        optimal_value = model.objVal

except GurobiError as e:
    # Model could not be optimized
    optimal_value = None

# Write only the numeric optimal value to file
try:
    with open('ref_optimal_value.txt', 'w') as f:
        if optimal_value is not None:
            f.write(str(optimal_value))
except IOError:
    pass",,19,variant_2
