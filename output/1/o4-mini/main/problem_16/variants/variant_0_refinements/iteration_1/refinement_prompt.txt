You are an expert operations research analyst. Based on the detailed diagnostic evaluation below, please generate an improved Gurobi solution for this optimization problem.

    ## Problem Description:
    A store plans to formulate the purchasing and sales plan for a certain product for the first quarter of next year. It is known that the warehouse capacity of the store can store up to 500 units of the product, and there are 200 units in stock at the end of this year. The store purchases goods once at the beginning of each month. The purchasing and selling prices of the product in each month are shown in Table 1.3.

Table 1.3

| Month | 1 | 2 | 3 |
| :---: | :---: | :---: | :---: |
| Purchasing Price (Yuan) | 8 | 6 | 9 |
| Selling Price (Yuan) | 9 | 8 | 10 |

Now, determine how many units should be purchased and sold each month to maximize the total profit, and express this problem as a linear programming model.

    ## Current Iteration: 1

    ## Diagnostic Evaluation Results:
    **DIMENSION 1 – Definition Consistency**  
Diagnosis:  
The model’s five-tuple matches the textual description in almost every respect:  
• Sets and indices (months 1–3) are correct.  
• Decision variables xₜ (purchase), yₜ (sales), sₜ (end-of-month inventory) are sensibly named.  
• Parameters bₜ, pₜ, s₀=200, S_max=500 agree with the statement.  

However, the verbal problem implicitly assumes there is a finite market demand or some limit on how many units can actually be sold each month. No such demand data appear in the model. As written, the store can buy unlimited product and immediately turn around and sell it within the same month, respecting only the end-of-month capacity constraint sₜ≤500.  

Issues Found:  
• Missing Demand Constraints: the model never caps yₜ by any realistic monthly demand Dₜ.  
• No salvage or terminal‐inventory treatment: leftover stock at month 3 has no penalty or value, which may not reflect reality (though the problem statement doesn’t specify it).  

Confidence: High  

**DIMENSION 2 – Structural Soundness**  
Diagnosis:  
• Objective: correctly set as maximize ∑(pₜ·yₜ–bₜ·xₜ).  
• Inventory‐balance and capacity constraints: correctly linear, one per month.  
• Variable types: continuous non-negative – reasonable if fractional units allowed.  

Missing/Redundant Constraints:  
• Missing upper bounds on yₜ (month-t demand) ⇒ allows infinite sales as soon as inventory arrives.  
• No upper bound on xₜ (procurement capacity) ⇒ infinite buying is feasible provided it is immediately sold.  

Model Type: pure LP is appropriate once demand is bounded; no integer or binary structure is implied.  

Issues Found:  
• Demand constraints yₜ ≤ Dₜ are absent.  
• No procurement limit or lead‐time restrictions.  
• No terminal inventory requirement/valuation (e.g. s₃=0 or salvage value).  

Confidence: High  

**DIMENSION 3 – Numerical Validity**  
Diagnosis:  
The Gurobi run reports “Infeasible or unbounded model” in 0 iterations. A little manual analysis shows it is in fact unbounded:  
– In any month t, the store can choose xₜ large, set yₜ≈xₜ+(previous inventory) so that end inventory sₜ ≈ 0 (respecting sₜ≤500), and pocket (pₜ–bₜ)·xₜ profit on each extra unit.  
– Month 2 has a positive margin (p₂–b₂=2), so infinite profit is possible.  

Issues Found:  
• Unboundedness due to missing demand or purchase‐capacity constraints.  

Confidence: High  

**OVERALL ASSESSMENT**  
Primary Issues:  
1. **Unbounded LP** – No cap on sales (yₜ) or purchases (xₜ) ⇒ infinite profit.  
2. **Missing demand data** – yₜ must be bounded by realistic monthly demand Dₜ.  
3. **Terminal inventory treatment** – usually either require s₃=0 or assign a salvage value/cost.  

Recommended Actions:  
1. Introduce explicit monthly demand limits: add constraints  
   yₜ ≤ Dₜ  for t=1,2,3  (populate Dₜ from data or assume values).  
2. If the store cannot order unlimited product in a single month, add purchase‐capacity constraints, e.g.  
   xₜ ≤ Q_max.  
3. Decide on end-of-horizon inventory policy: either fix s₃=0 (no leftovers) or include a salvage value term in the objective.  
4. Re-run optimization to verify boundedness and reasonableness of the resulting purchase/sales plan.  

With those fixes the model will become well-posed and deliver a unique, realistic maximum-profit solution.

    ## Current 5element to Improve:
    Sets:
T = {1, 2, 3}  // Index set for months

Variables:
x_t ≥ 0  (continuous)  // Units purchased in month t, for t ∈ T
y_t ≥ 0  (continuous)  // Units sold in month t, for t ∈ T
s_t ≥ 0  (continuous)  // Inventory at the end of month t, for t ∈ T

Parameters:
b_t       // Purchase price in month t (b_1=8, b_2=6, b_3=9)
p_t       // Selling price in month t  (p_1=9, p_2=8, p_3=10)
s0 = 200  // Initial inventory at end of month 0
S_max = 500 // Warehouse capacity

Constraints:
1) Inventory balance for each t ∈ T:
   s_t = (s_{t-1}) + x_t - y_t
   where s_{0} = s0

2) Capacity limit for each t ∈ T:
   s_t ≤ S_max

3) Non-negativity for all decision variables:
   x_t, y_t, s_t ≥ 0

Objective:
Maximize total profit = ∑_{t ∈ T} (p_t * y_t − b_t * x_t)

    ## Current Solution to Improve:
    ```python
    import gurobipy as gp
from gurobipy import GRB

# Data
T = [1, 2, 3]
b = {1: 8, 2: 6, 3: 9}    # purchase prices
p = {1: 9, 2: 8, 3: 10}   # selling prices
s0 = 200                 # initial inventory
S_max = 500              # warehouse capacity

# Model
model = gp.Model("Purchasing_Sales_Plan")

# Decision variables
x = model.addVars(T, lb=0, name="purchase")   # x[t]: units purchased in month t
y = model.addVars(T, lb=0, name="sales")      # y[t]: units sold in month t
s = model.addVars(T, lb=0, name="inventory")  # s[t]: inventory at end of month t

# Inventory balance constraints
for t in T:
    if t == 1:
        model.addConstr(s[t] == s0 + x[t] - y[t], name=f"inv_balance_{t}")
    else:
        model.addConstr(s[t] == s[t-1] + x[t] - y[t], name=f"inv_balance_{t}")

# Capacity constraints
for t in T:
    model.addConstr(s[t] <= S_max, name=f"capacity_{t}")

# Objective: maximize profit
model.setObjective(gp.quicksum(p[t] * y[t] - b[t] * x[t] for t in T), GRB.MAXIMIZE)

# Optimize
model.optimize()

# Write optimal value to file
if model.status == GRB.OPTIMAL:
    with open('ref_optimal_value.txt', 'w') as f:
        f.write(str(model.objVal))
    ```

    ## Instructions for Improvement:

    Based on the diagnostic evaluation above, please generate a completely new and improved Gurobi code that addresses ALL identified issues. 

    **Requirements:**
    1. Address each issue identified in the diagnostic evaluation
    2. Ensure the code can run successfully without errors
    3. Save the final optimal value to 'ref_optimal_value.txt' (value only, no extra text)
    4. Use proper Gurobi syntax and best practices
    5. Include appropriate error handling
    6. Add clear comments explaining key modeling decisions

    **Code Generation Format:**
    First, provide a brief explanation of the key improvements you're making, then provide the complete code between ===== markers:

    Key Improvements:
    [Explain the main changes you're making to address the identified issues]

    =====
    import gurobipy as gp
    from gurobipy import GRB

    # Your improved code here
    # Make sure to save only the optimal value to 'ref_optimal_value.txt'
    =====

    Please ensure the generated code is complete, executable, and addresses all the issues identified in the diagnostic evaluation.
    