+++++
Sets:
  Products: P = {chair, dresser}

Variables:
  x[p] for p in P, continuous ≥ 0
    x[chair] = number of chairs produced
    x[dresser] = number of dressers produced

Parameters:
  profit[p] for p in P:
    profit[chair] = 43
    profit[dresser] = 52
  stain_req[p] for p in P:
    stain_req[chair] = 1.4
    stain_req[dresser] = 1.1
  wood_req[p] for p in P:
    wood_req[chair] = 2
    wood_req[dresser] = 3
  stain_avail = 17 (gallons)
  wood_avail = 11 (lengths)

Constraints:
  1) Stain usage: ∑_{p∈P} stain_req[p] * x[p] ≤ stain_avail
  2) Wood usage: ∑_{p∈P} wood_req[p] * x[p] ≤ wood_avail
  3) x[p] ≥ 0 for all p ∈ P

Objective:
  Maximize total profit = ∑_{p∈P} profit[p] * x[p]
+++++

=====
import gurobipy as gp
from gurobipy import GRB

# Data
profits = {'chair': 43, 'dresser': 52}
stain_req = {'chair': 1.4, 'dresser': 1.1}
wood_req = {'chair': 2,   'dresser': 3}
stain_avail = 17
wood_avail = 11

# Model
model = gp.Model()

# Decision variables
x = model.addVars(profits.keys(), lb=0, vtype=GRB.CONTINUOUS, name='x')

# Constraints
model.addConstr(
    gp.quicksum(stain_req[p] * x[p] for p in profits) <= stain_avail,
    name='StainCapacity'
)
model.addConstr(
    gp.quicksum(wood_req[p] * x[p] for p in profits) <= wood_avail,
    name='WoodCapacity'
)

# Objective
model.setObjective(
    gp.quicksum(profits[p] * x[p] for p in profits),
    GRB.MAXIMIZE
)

# Solve
model.optimize()

# Save optimal value
opt_val = model.objVal
with open('ref_optimal_value.txt', 'w') as f:
    f.write(str(opt_val))
=====