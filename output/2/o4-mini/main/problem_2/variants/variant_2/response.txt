+++++
Sets:
  J = {1,2,3}                                 # Set of jobs
  P = {1,2,3}                                 # Set of sequence positions
  M = {1,2}                                   # Set of machines

Variables:
  X[j,p] ∈ {0,1}   for j ∈ J, p ∈ P          # 1 if job j is assigned to position p
  C[p,m] ≥ 0      for p ∈ P, m ∈ M           # Completion time of the job in position p on machine m

Parameters:
  p[j,m] = proces_time[j-1][m-1]            # Processing time of job j on machine m
  n = |J| = 3
  num_m = |M| = 2

Constraints:
  # Assignment constraints
  ∑_{j∈J} X[j,p] = 1     ∀p ∈ P             # Exactly one job per position
  ∑_{p∈P} X[j,p] = 1     ∀j ∈ J             # Each job appears in exactly one position

  # Completion‐time recursion on machine 1
  C[1,1] ≥ ∑_{j∈J} p[j,1] * X[j,1]
  C[p,1] ≥ C[p-1,1] + ∑_{j∈J} p[j,1] * X[j,p]   ∀p = 2..n

  # Completion‐time recursion for machines m>1
  For m=2:
    C[1,2] ≥ C[1,1] + ∑_{j∈J} p[j,2] * X[j,1]
    C[p,2] ≥ C[p,1] + ∑_{j∈J} p[j,2] * X[j,p]
    C[p,2] ≥ C[p-1,2] + ∑_{j∈J} p[j,2] * X[j,p]  ∀p=2..n

Objective:
  Minimize makespan = C[n,2]   # Completion time of the last position on the last machine
+++++

=====
import gurobipy as gp
from gurobipy import GRB

# Data
jobs = [1, 2, 3]
machines = [1, 2]
proces_time = {
    (1,1): 1, (1,2): 3,
    (2,1): 2, (2,2): 2,
    (3,1): 3, (3,2): 1
}
n = len(jobs)

# Model
model = gp.Model("flowshop_2machines")

# Variables
X = model.addVars(jobs, jobs, vtype=GRB.BINARY, name="X")  # X[j,p]
C = model.addVars(range(1, n+1), machines, lb=0.0, vtype=GRB.CONTINUOUS, name="C")  # C[p,m]

# Assignment constraints
for p in jobs:
    model.addConstr(gp.quicksum(X[j,p] for j in jobs) == 1, name=f"oneJobAtPos_{p}")
for j in jobs:
    model.addConstr(gp.quicksum(X[j,p] for p in jobs) == 1, name=f"jobOnce_{j}")

# Completion time constraints on machine 1
# Position 1
model.addConstr(
    C[1,1] >= gp.quicksum(proces_time[j,1] * X[j,1] for j in jobs),
    name="C_1_1"
)
# Positions 2..n
for p in range(2, n+1):
    model.addConstr(
        C[p,1] >= C[p-1,1] + gp.quicksum(proces_time[j,1] * X[j,p] for j in jobs),
        name=f"C_{p}_1"
    )

# Completion time constraints on machine 2
# Position 1 on machine 2
model.addConstr(
    C[1,2] >= C[1,1] + gp.quicksum(proces_time[j,2] * X[j,1] for j in jobs),
    name="C_1_2"
)
# Positions 2..n on machine 2
for p in range(2, n+1):
    model.addConstr(
        C[p,2] >= C[p,1] + gp.quicksum(proces_time[j,2] * X[j,p] for j in jobs),
        name=f"Cpos_{p}_m2_depOn_m1"
    )
    model.addConstr(
        C[p,2] >= C[p-1,2] + gp.quicksum(proces_time[j,2] * X[j,p] for j in jobs),
        name=f"Cpos_{p}_m2_seq"
    )

# Objective: minimize makespan (completion of last job on last machine)
model.setObjective(C[n,2], GRB.MINIMIZE)

# Optimize
model.optimize()

# Save optimal value
with open('ref_optimal_value.txt', 'w') as f:
    f.write(str(model.objVal))

# (Optional) print solution
# if model.status == GRB.OPTIMAL:
#     print("Optimal makespan:", model.objVal)
#     for p in jobs:
#         for j in jobs:
#             if X[j,p].X > 0.5:
#                 print(f"Position {p}: Job {j}")
=====
