Key Improvements:
- Removed the unused `schedules` list and corrected the typo from `proces_time` to `process_time`.
- Added robust import‐error handling to exit gracefully if Gurobi is not installed.
- Applied clear variable naming and comments for readability.
- Kept a single Big-M bound computed from the sum of all processing times.
- Ensured the script writes only the numeric optimal makespan to `ref_optimal_value.txt` and handles non‐optimal solver statuses.

=====
import sys

# 1. Ensure Gurobi is installed
try:
    import gurobipy as gp
    from gurobipy import GRB
except ImportError:
    sys.exit("Error: gurobipy not found. Please install the Gurobi Python API (gurobipy).")

# 2. Problem data (2‐machine flow shop, 3 jobs)
jobs = [1, 2, 3]
machines = [1, 2]
process_time = {
    (1, 1): 1, (1, 2): 3,
    (2, 1): 2, (2, 2): 2,
    (3, 1): 3, (3, 2): 1
}

# Compute a safe Big-M bound as the sum of all processing times
Mbig = sum(process_time.values())

# 3. Build the model
model = gp.Model("flowshop_2machine_3jobs")
# Turn off Gurobi output for clean runs, set a 30s time limit
model.Params.OutputFlag = 0
model.Params.TimeLimit = 30

# 4. Decision variables
# S[j,m] = start time of job j on machine m
S = model.addVars(jobs, machines, lb=0.0, vtype=GRB.CONTINUOUS, name="S")
# y[i,j] for i<j: binary indicating job i precedes job j on both machines
pair_indices = [(i, j) for i in jobs for j in jobs if i < j]
y = model.addVars(pair_indices, vtype=GRB.BINARY, name="y")
# Cmax = makespan
Cmax = model.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name="Cmax")

# 5. Constraints

# 5.1 Disjunctive (no‐overlap) constraints on each machine
for i, j in pair_indices:
    # Machine 1 constraints
    model.addConstr(
        S[i, 1] + process_time[(i, 1)]
        <= S[j, 1] + Mbig * (1 - y[i, j]),
        name=f"m1_{i}_before_{j}"
    )
    model.addConstr(
        S[j, 1] + process_time[(j, 1)]
        <= S[i, 1] + Mbig * y[i, j],
        name=f"m1_{j}_before_{i}"
    )
    # Machine 2 constraints
    model.addConstr(
        S[i, 2] + process_time[(i, 2)]
        <= S[j, 2] + Mbig * (1 - y[i, j]),
        name=f"m2_{i}_before_{j}"
    )
    model.addConstr(
        S[j, 2] + process_time[(j, 2)]
        <= S[i, 2] + Mbig * y[i, j],
        name=f"m2_{j}_before_{i}"
    )

# 5.2 In‐job precedence: each job must finish on machine 1 before starting on machine 2
for j in jobs:
    model.addConstr(
        S[j, 2] >= S[j, 1] + process_time[(j, 1)],
        name=f"prec_{j}"
    )

# 5.3 Defines makespan: Cmax ≥ completion time of each job on machine 2
for j in jobs:
    model.addConstr(
        Cmax >= S[j, 2] + process_time[(j, 2)],
        name=f"cmax_def_{j}"
    )

# 6. Objective: minimize makespan
model.setObjective(Cmax, GRB.MINIMIZE)

# 7. Solve with error handling
try:
    model.optimize()
    if model.Status != GRB.OPTIMAL:
        sys.exit(f"Error: solver ended with status {model.Status}")
except gp.GurobiError as e:
    sys.exit(f"Gurobi Error: {e}")

# 8. Write the numeric optimal makespan to file
with open("ref_optimal_value.txt", "w") as out_file:
    out_file.write(str(model.ObjVal))
=====