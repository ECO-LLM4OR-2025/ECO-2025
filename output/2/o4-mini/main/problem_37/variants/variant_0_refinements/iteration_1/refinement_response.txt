Key Improvements:
1. Added robust import handling: if Gurobiâ€™s gurobipy is missing, the script falls back to PuLP (CBC) automatically.
2. Wrapped the solve phase in try/except to catch and report any solver errors.
3. Checked solver status to ensure an optimal solution was found before writing output.
4. Used clear comments, context managers, and best practices for both Gurobi and PuLP setups.
5. Ensured only the numeric optimal value is written to `ref_optimal_value.txt`.

=====
```python
import sys

# First, attempt to import Gurobi. If unavailable, fall back to PuLP.
try:
    import gurobipy as gp
    from gurobipy import GRB
    SOLVER = "gurobi"
except ModuleNotFoundError:
    try:
        import pulp
        SOLVER = "pulp"
    except ModuleNotFoundError:
        sys.exit("Error: Neither gurobipy nor pulp is installed. Please install one solver.")

# Problem data
products = ["thin", "stubby"]
shape_time = {"thin": 50, "stubby": 30}
bake_time  = {"thin": 90, "stubby": 150}
shape_cap  = 3000
bake_cap   = 4000
profit     = {"thin": 5, "stubby": 9}

optimal_value = None

if SOLVER == "gurobi":
    try:
        # Create Gurobi model
        model = gp.Model("jar_production")
        model.setParam("OutputFlag", 0)  # silence solver output

        # Decision variables: integer, non-negative
        x = {}
        for p in products:
            x[p] = model.addVar(vtype=GRB.INTEGER, lb=0, name=f"x_{p}")

        model.update()

        # Capacity constraints
        model.addConstr(
            gp.quicksum(shape_time[p] * x[p] for p in products) <= shape_cap,
            name="shaping_capacity"
        )
        model.addConstr(
            gp.quicksum(bake_time[p] * x[p] for p in products) <= bake_cap,
            name="baking_capacity"
        )

        # Objective: maximize profit
        model.setObjective(
            gp.quicksum(profit[p] * x[p] for p in products),
            GRB.MAXIMIZE
        )

        # Solve
        model.optimize()

        if model.Status == GRB.OPTIMAL:
            optimal_value = model.ObjVal
        else:
            sys.exit(f"Gurobi did not find an optimal solution (status {model.Status}).")

    except gp.GurobiError as e:
        sys.exit(f"Gurobi error: {e}")

elif SOLVER == "pulp":
    try:
        # Create PuLP model
        prob = pulp.LpProblem("jar_production", pulp.LpMaximize)

        # Decision variables
        x = {
            p: pulp.LpVariable(f"x_{p}", lowBound=0, cat="Integer")
            for p in products
        }

        # Capacity constraints
        prob += pulp.lpSum(shape_time[p] * x[p] for p in products) <= shape_cap, "shaping_capacity"
        prob += pulp.lpSum(bake_time[p] * x[p] for p in products)  <= bake_cap, "baking_capacity"

        # Objective
        prob += pulp.lpSum(profit[p] * x[p] for p in products), "Total_Profit"

        # Solve with default CBC
        result_status = prob.solve(pulp.PULP_CBC_CMD(msg=False))

        if pulp.LpStatus[result_status] == "Optimal":
            optimal_value = pulp.value(prob.objective)
        else:
            sys.exit(f"PuLP did not find an optimal solution (status {pulp.LpStatus[result_status]}).")

    except Exception as e:
        sys.exit(f"PuLP error: {e}")

# Write only the numeric optimal value to file
if optimal_value is None:
    sys.exit("No optimal value was computed; aborting write.")
with open("ref_optimal_value.txt", "w") as f:
    f.write(str(int(optimal_value) if optimal_value.is_integer() else str(optimal_value)))
```
=====