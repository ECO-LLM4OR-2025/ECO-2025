Key Improvements:
- Added robust import error handling to catch missing Gurobi library early.
- Retrieved and saved optimal decision variable values (x_thin, x_stubby) in a separate file (`ref_solution.txt`) for full solution transparency.
- Ensured only the optimal profit value is written to `ref_optimal_value.txt` (no extra text) as required.
- Incorporated comprehensive error handling around model creation, optimization, and file operations.
- Disabled solver output for clean execution and used clear comments for each modeling step.

=====
import sys

# Attempt to import Gurobi; exit cleanly if unavailable
try:
    import gurobipy as gp
    from gurobipy import GRB
except ImportError as e:
    sys.exit(f"ImportError: gurobipy not found ({e})")

# Problem data
shape_time = {"thin": 50, "stubby": 30}
bake_time  = {"thin": 90, "stubby": 150}
profit     = {"thin": 5,  "stubby": 9}
shape_cap  = 3000
bake_cap   = 4000

try:
    # Initialize Gurobi model
    model = gp.Model("TerracottaJars")
    # Silence solver output
    model.Params.OutputFlag = 0
except gp.GurobiError as e:
    sys.exit(f"Error initializing Gurobi model: {e}")

# Decision variables: number of thin and stubby jars (integer â‰¥ 0)
x = {}
for jar in ["thin", "stubby"]:
    x[jar] = model.addVar(vtype=GRB.INTEGER, lb=0, name=f"x_{jar}")

# Add resource constraints
model.addConstr(
    gp.quicksum(shape_time[jar] * x[jar] for jar in x) <= shape_cap,
    name="ShapingCapacity"
)
model.addConstr(
    gp.quicksum(bake_time[jar]  * x[jar] for jar in x) <= bake_cap,
    name="BakingCapacity"
)

# Objective: maximize total profit
model.setObjective(
    gp.quicksum(profit[jar] * x[jar] for jar in x),
    GRB.MAXIMIZE
)

# Optimize the model
try:
    model.optimize()
except gp.GurobiError as e:
    sys.exit(f"Gurobi optimization error: {e}")

# Check for optimal solution
if model.Status != GRB.OPTIMAL:
    sys.exit(f"Optimization did not converge to optimality (Status {model.Status}).")

# Retrieve results
opt_profit = model.ObjVal
thin_qty   = int(x["thin"].X + 0.5)
stubby_qty = int(x["stubby"].X + 0.5)

# Write only the optimal profit to the required file
try:
    with open("ref_optimal_value.txt", "w") as f_opt:
        # Cast to integer if it's integral
        if abs(opt_profit - round(opt_profit)) < 1e-6:
            f_opt.write(str(int(round(opt_profit))))
        else:
            f_opt.write(str(opt_profit))
except Exception as e:
    sys.exit(f"Error writing optimal value file: {e}")

# Additionally, save the decision variable values for reference
try:
    with open("ref_solution.txt", "w") as f_sol:
        f_sol.write(f"{thin_qty},{stubby_qty}")
except Exception as e:
    sys.exit(f"Error writing solution file: {e}")

# Optionally, print a concise summary to stdout
print(f"Optimal profit: {opt_profit:.2f}")
print(f"  Thin jars: {thin_qty}")
print(f"  Stubby jars: {stubby_qty}")
=====