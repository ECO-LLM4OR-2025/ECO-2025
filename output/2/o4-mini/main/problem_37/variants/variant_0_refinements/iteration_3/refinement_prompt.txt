You are an expert operations research analyst. Based on the detailed diagnostic evaluation below, please generate an improved Gurobi solution for this optimization problem.

    ## Problem Description:
    An artisan makes two types of terracotta jars: a thin jar and a stubby jar. Each thin jar requires 50 minutes of shaping time and 90 minutes of baking time. Each stubby jar requires 30 minutes of shaping time and 150 minutes of baking time. Per week, there are 3000 minutes available for shaping and 4000 minutes available for baking. The profit per thin jar is $5 and the profit per stubby jar is $9. How many jars of each type should the artisan make to maximize profit?

    ## Current Iteration: 3

    ## Diagnostic Evaluation Results:
    **DIMENSION 1 – Definition Consistency**  
Diagnosis: The model’s data structures (shape_time, bake_time, profit, shape_cap, bake_cap) and decision variables x_thin and x_stubby fully align with the problem description. The two product types (“thin” and “stubby”), their resource requirements, capacities, and profit contributions are all captured correctly.  
Issues Found: None  
Confidence: High  

**DIMENSION 2 – Structural Soundness**  
Diagnosis:  
- Objective: correctly specified as a maximization of total profit.  
- Constraints: both shaping‐time and baking‐time caps are present and accurately formulated.  
- Model type: integer variables are reasonable here (even though the LP relaxation yields integer solutions, the integer domain is not harmful).  
- No constraints are missing or redundant.  
Issues Found: None  
Confidence: High  

**DIMENSION 3 – Numerical Validity**  
Diagnosis:  
- There are no infeasibility or unboundedness concerns given the data.  
- All coefficients and right‐hand sides are consistent with the statement.  
- The failure arises solely at execution: Python cannot import gurobipy.  
Issues Found:  
1. ModuleNotFoundError: gurobipy is not installed or available in the runtime environment.  
Confidence: High  

**OVERALL ASSESSMENT**  
Primary Issues:  
1. The solver library (gurobipy) is unavailable, causing the script to crash before testing feasibility or computing an optimum.  
2. The code writes only the optimal objective value; it does not export the recommended production quantities (x_thin, x_stubby).  

Recommended Actions:  
- Install or enable Gurobi/`gurobipy`, or switch to a Python‐native solver (e.g., PuLP, OR-Tools) by rewriting the import and solve calls accordingly.  
- After `model.optimize()`, retrieve and write out both x["thin"] and x["stubby"] values (in addition to ObjVal) so you know the optimal jar counts, e.g.:  
  f.write(f"{int(x['thin'].X)}, {int(x['stubby'].X)}, {int(round(opt_val))}")  
- Verify in the new environment that the model runs to optimality and that the solution matches expectations (it should choose the mix that exhausts one or both resources).

    ## Current 5element to Improve:
    No 5element_description

    ## Current Solution to Improve:
    ```python
    import sys
import gurobipy as gp
from gurobipy import GRB

# Problem data
shape_time = { "thin": 50, "stubby": 30 }
bake_time  = { "thin": 90, "stubby": 150 }
profit     = { "thin": 5,  "stubby": 9 }
shape_cap  = 3000
bake_cap   = 4000

try:
    # Initialize Gurobi model
    model = gp.Model("TerracottaJars")
except Exception as e:
    sys.exit(f"Error initializing Gurobi model: {e}")

# Silence solver log
model.setParam(GRB.Param.OutputFlag, 0)

# Decision variables: number of thin and stubby jars (integer, ≥0)
x = {}
for p in ["thin", "stubby"]:
    x[p] = model.addVar(vtype=GRB.INTEGER, lb=0, name=f"x_{p}")

model.update()

# Resource constraints
# 1) Shaping time capacity
model.addConstr(
    gp.quicksum(shape_time[p] * x[p] for p in x) <= shape_cap,
    name="ShapingCapacity"
)
# 2) Baking time capacity
model.addConstr(
    gp.quicksum(bake_time[p] * x[p] for p in x) <= bake_cap,
    name="BakingCapacity"
)

# Objective: maximize total profit
model.setObjective(
    gp.quicksum(profit[p] * x[p] for p in x),
    GRB.MAXIMIZE
)

# Solve the model
try:
    model.optimize()
except gp.GurobiError as e:
    sys.exit(f"Gurobi optimization error: {e}")

# Check solution status
if model.Status != GRB.OPTIMAL:
    sys.exit(f"Optimization ended with status {model.Status} (not optimal).")

# Retrieve optimal objective value
opt_val = model.ObjVal

# Write only the numeric optimal value to file
try:
    with open("ref_optimal_value.txt", "w") as f:
        # Cast to integer if the result is integral
        if abs(opt_val - round(opt_val)) < 1e-6:
            f.write(str(int(round(opt_val))))
        else:
            f.write(str(opt_val))
except Exception as e:
    sys.exit(f"Error writing output file: {e}")
    ```

    ## Instructions for Improvement:

    Based on the diagnostic evaluation above, please generate a completely new and improved Gurobi code that addresses ALL identified issues. 

    **Requirements:**
    1. Address each issue identified in the diagnostic evaluation
    2. Ensure the code can run successfully without errors
    3. Save the final optimal value to 'ref_optimal_value.txt' (value only, no extra text)
    4. Use proper Gurobi syntax and best practices
    5. Include appropriate error handling
    6. Add clear comments explaining key modeling decisions

    **Code Generation Format:**
    First, provide a brief explanation of the key improvements you're making, then provide the complete code between ===== markers:

    Key Improvements:
    [Explain the main changes you're making to address the identified issues]

    =====
    import gurobipy as gp
    from gurobipy import GRB

    # Your improved code here
    # Make sure to save only the optimal value to 'ref_optimal_value.txt'
    =====

    Please ensure the generated code is complete, executable, and addresses all the issues identified in the diagnostic evaluation.
    