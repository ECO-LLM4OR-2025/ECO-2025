Key Improvements:
- Added ImportError handling to provide a clear message if Gurobi is not installed or not licensed.
- Encapsulated the modeling and solution logic in a `main()` function for clarity and easy maintenance.
- Created individual variables with explicit bounds to ensure correct per-aircraft window settings.
- Checked the solverâ€™s status after optimization to handle infeasible or unbounded cases gracefully.
- Used Gurobi parameters (e.g., `OutputFlag`) for controlled logging.
- Included concise comments on key modeling decisions and steps.
- Ensured the output file contains only the numeric optimal value.

=====
import sys

def main():
    try:
        import gurobipy as gp
        from gurobipy import GRB
    except ImportError:
        sys.stderr.write(
            "ERROR: The Gurobi Python package 'gurobipy' is not installed or could not be imported.\n"
            "Please ensure that Gurobi is installed, licensed, and that 'gurobipy' is on your PYTHONPATH.\n"
        )
        sys.exit(1)

    # Problem data
    E = [1, 3, 5]                # Earliest landing times
    L = [10, 12, 15]             # Latest landing times
    T = [4, 8, 14]               # Target landing times
    alpha = [10, 20, 30]         # Penalty per unit tardiness
    beta = [5, 10, 15]           # Penalty per unit earliness
    sep = [
        [0, 2, 3],
        [2, 0, 4],
        [3, 4, 0]
    ]
    n = len(E)
    I = range(n)

    # Create Gurobi model
    model = gp.Model("AircraftLanding")
    model.setParam("OutputFlag", 1)   # Enable Gurobi logging

    # Decision variables
    x = {}        # Landing times
    eplus = {}    # Tardiness
    eminus = {}   # Earliness
    for i in I:
        x[i] = model.addVar(lb=E[i], ub=L[i], name=f"x_{i}")
        eplus[i] = model.addVar(lb=0.0, name=f"eplus_{i}")
        eminus[i] = model.addVar(lb=0.0, name=f"eminus_{i}")

    model.update()

    # Earliness/tardiness balance constraints
    for i in I:
        # x_i - T_i = eplus_i - eminus_i
        model.addConstr(
            x[i] - T[i] == eplus[i] - eminus[i],
            name=f"balance_{i}"
        )

    # Separation constraints enforcing fixed order 1->2->3 (indices 0->1->2)
    for i in I:
        for j in I:
            if i < j:
                model.addConstr(
                    x[j] >= x[i] + sep[i][j],
                    name=f"sep_{i}_{j}"
                )

    # Objective: minimize total earliness and tardiness penalties
    obj = gp.quicksum(alpha[i] * eplus[i] + beta[i] * eminus[i] for i in I)
    model.setObjective(obj, GRB.MINIMIZE)

    # Optimize the model
    model.optimize()

    # Check solution status
    status = model.Status
    if status != GRB.OPTIMAL:
        sys.stderr.write(f"ERROR: Optimization ended with status {status}, not OPTIMAL.\n")
        sys.exit(2)

    # Retrieve and save optimal objective value
    opt_val = model.ObjVal
    try:
        with open("ref_optimal_value.txt", "w") as f:
            f.write(f"{opt_val}")
    except IOError as e:
        sys.stderr.write(f"ERROR: Could not write to file: {e}\n")
        sys.exit(3)

if __name__ == "__main__":
    main()
=====