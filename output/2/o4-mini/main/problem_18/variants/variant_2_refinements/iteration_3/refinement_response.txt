Key Improvements:
1. Enforce a general landing sequence rather than assuming input order by introducing binary sequencing variables y[i,j].
2. Implement big-M constraints for separation times based on y[i,j].
3. Provide clear error messages if Gurobi is not available or model creation/solution fails.
4. Compute a valid big-M automatically from data to preserve correctness.
5. Use best practices in Gurobi Python API (vectorized variable creation, parameter setting).
6. Add comments explaining modeling decisions and ensure only the optimal value is written to file.

=====
import sys
import os

# Problem data
E = [1, 3, 5]                # Earliest landing times
L = [10, 12, 15]             # Latest landing times
T = [4, 8, 14]               # Target landing times
alpha = [10, 20, 30]         # Penalty per unit tardiness (after target)
beta = [5, 10, 15]           # Penalty per unit earliness (before target)
sep = [
    [0, 2, 3],
    [2, 0, 4],
    [3, 4, 0]
]
n = len(E)
I = range(n)

# Compute a valid big-M for separation constraints:
# M >= (max latest landing - min earliest landing) + max separation
try:
    max_L = max(L)
    min_E = min(E)
    max_sep = max(sep[i][j] for i in I for j in I)
    M = (max_L - min_E) + max_sep
except Exception as e:
    sys.stderr.write(f"ERROR computing big-M: {e}\n")
    sys.exit(1)

# Try importing Gurobi
try:
    import gurobipy as gp
    from gurobipy import GRB
except ImportError:
    sys.stderr.write("ERROR: Gurobi Python interface is not installed.\n")
    sys.exit(1)

# Build the model
try:
    model = gp.Model("AircraftLanding")
    # Turn on solver output for diagnostics
    model.Params.OutputFlag = 1
except gp.GurobiError as e:
    sys.stderr.write(f"ERROR: Could not create Gurobi model: {e}\n")
    sys.exit(1)

# Decision variables
# x[i]: landing time of aircraft i
# eplus[i], eminus[i]: tardiness / earliness slack
# y[i,j]: binary, 1 if i lands before j
x = model.addVars(n, lb=E, ub=L, name="x")
eplus = model.addVars(n, lb=0.0, name="eplus")
eminus = model.addVars(n, lb=0.0, name="eminus")
y = model.addVars(n, n, vtype=GRB.BINARY, name="y")

model.update()

# 1) Balance constraints for earliness/tardiness
for i in I:
    # x_i - T_i = eplus_i - eminus_i
    model.addConstr(x[i] - T[i] == eplus[i] - eminus[i], name=f"balance_{i}")

# 2) Sequencing constraints: for each pair i < j, either i precedes j or vice versa
for i in I:
    for j in I:
        if i < j:
            model.addConstr(y[i, j] + y[j, i] == 1, name=f"order_{i}_{j}")

# 3) Separation constraints using big-M:
# If y[i,j]=1 (i before j), then x[j] >= x[i] + sep[i][j]
# Otherwise, constraint is relaxed by big-M
for i in I:
    for j in I:
        if i != j:
            model.addConstr(
                x[j] >= x[i] + sep[i][j] - M * (1 - y[i, j]),
                name=f"sep_{i}_{j}"
            )

# 4) Objective: minimize total earliness/tardiness penalty
obj = gp.quicksum(alpha[i] * eplus[i] + beta[i] * eminus[i] for i in I)
model.setObjective(obj, GRB.MINIMIZE)

# Optimize the model
try:
    model.optimize()
except gp.GurobiError as e:
    sys.stderr.write(f"ERROR: Gurobi optimization failed: {e}\n")
    sys.exit(2)

# Check for optimal solution
if model.Status != GRB.OPTIMAL:
    sys.stderr.write(f"ERROR: Optimization ended with status {model.Status}\n")
    sys.exit(3)

# Retrieve optimal objective value
opt_val = model.ObjVal

# Write the numeric optimal value only to file
out_file = "ref_optimal_value.txt"
try:
    with open(out_file, "w") as f:
        f.write(f"{opt_val}")
except IOError as e:
    sys.stderr.write(f"ERROR: Could not write to '{out_file}': {e}\n")
    sys.exit(4)

# End of script
=====