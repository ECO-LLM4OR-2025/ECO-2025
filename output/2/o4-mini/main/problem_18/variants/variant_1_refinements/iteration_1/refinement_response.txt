Key Improvements:
1. Added try/except around the gurobipy import to catch missing‐module errors and provide a user‐friendly message.
2. Encapsulated the model building and solving logic in a `main()` function with a standard `if __name__ == "__main__"` guard.
3. Employed Gurobi’s `gp.INFINITY` for unbounded variable definitions and left time‐window enforcement to explicit constraints.
4. Introduced error handling for both the optimization call and the file‐write operation.
5. Ensured that only the numeric optimal objective value is written to `ref_optimal_value.txt` with no extra formatting.

=====
import sys

# 1. Import Gurobi with error handling
try:
    import gurobipy as gp
    from gurobipy import GRB
except ImportError:
    sys.stderr.write("Error: gurobipy package not found. Please install gurobipy and ensure you have a valid license.\n")
    sys.exit(1)

def main():
    # 2. Data definition
    I = [1, 2, 3]
    EarliestLanding = {1: 1,  2: 3,  3: 5}
    LatestLanding   = {1: 10, 2: 12, 3: 15}
    TargetLanding   = {1: 4,  2: 8,  3: 14}
    PenBefore       = {1: 5,  2: 10, 3: 15}
    PenAfter        = {1: 10, 2: 20, 3: 30}
    SeparationTime  = {
        (1,2): 2, (1,3): 3,
        (2,3): 4
    }

    try:
        # 3. Create model
        model = gp.Model("AircraftLanding")

        # 4. Decision variables
        #    t[i] = landing time (real, unbounded, time-windows enforced by constraints)
        #    e[i], l[i] = early/late deviations (nonnegative)
        t = model.addVars(I, lb=-gp.INFINITY, ub=gp.INFINITY, name="t")
        e = model.addVars(I, lb=0.0, name="e")
        l = model.addVars(I, lb=0.0, name="l")

        # 5. Time-window constraints
        for i in I:
            model.addConstr(t[i] >= EarliestLanding[i], name=f"earliest_{i}")
            model.addConstr(t[i] <= LatestLanding[i],   name=f"latest_{i}")

        # 6. Separation constraints (i must land before j for i<j)
        for (i, j), sep in SeparationTime.items():
            model.addConstr(t[j] - t[i] >= sep, name=f"sep_{i}_{j}")

        # 7. Deviation constraints (absolute deviation from target)
        for i in I:
            model.addConstr(e[i] >= TargetLanding[i] - t[i], name=f"dev_early_{i}")
            model.addConstr(l[i] >= t[i] - TargetLanding[i], name=f"dev_late_{i}")

        # 8. Objective: minimize total early/late penalties
        obj = gp.quicksum(PenBefore[i] * e[i] + PenAfter[i] * l[i] for i in I)
        model.setObjective(obj, GRB.MINIMIZE)

        # Optional: silence Gurobi output or control log level
        # model.Params.OutputFlag = 0

        # 9. Optimize with error handling
        model.optimize()

    except gp.GurobiError as ge:
        sys.stderr.write(f"Gurobi error: {ge}\n")
        sys.exit(1)

    # 10. Check status and write result
    if model.Status == GRB.OPTIMAL:
        optimal_value = model.ObjVal
        try:
            with open("ref_optimal_value.txt", "w") as fout:
                fout.write(str(optimal_value))
        except IOError as ioe:
            sys.stderr.write(f"File write error: {ioe}\n")
            sys.exit(1)
    else:
        sys.stderr.write("Optimization did not reach an optimal solution.\n")
        sys.exit(1)

if __name__ == "__main__":
    main()
=====